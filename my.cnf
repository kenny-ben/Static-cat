# For advice on how to change settings please see
# http://dev.mysql.com/doc/refman/5.6/e ... nfiguration-defaults.html
# *** DO NOT EDIT THIS FILE. It's a template which will be copied to the
# *** default location during install, and will be replaced if you
# *** upgrade to a newer version of MySQL.

[client]
port = 3306
default-character-set = utf8
socket = /tmp/mysql.sock

[mysqld]
#数据库字符集
character_set_server = utf8
#不使用名称解析
skip-name-resolve
#防止创建函数报错
log_bin_trust_function_creators=1
# Remove leading # and set to the amount of RAM for the most important data
# cache in MySQL. Start at 70% of total RAM for dedicated server, else 10%.
# innodb_buffer_pool_size = 128M
#innodb_flush_log_at_trx_commit=1
# Remove leading # to turn on a very important data integrity option: logging
# changes to the binary log between backups.
# log_bin
log_bin=mysql-bin
binlog-do-db=uicdb
binlog-ignore-db=mysql
binlog-ignore-db=test
binlog-ignore-db=information_schema
log_bin_index=mysql-bin.index
binlog_format=mixed
expire_logs_days=5
# These are commonly set, remove the # and set as required.
# basedir = .....
# datadir = .....
# port = .....
# server_id = .....
# socket = .....
datadir = /opt/mysqldata/mysql
port = 3306
server_id = 1
socket = /tmp/mysql.sock
pid-file = /opt/mysqldata/mysql/mysql.pid
#错误日志
log-error = /opt/mysqldata/mysql/mysql_error.log

#忽略大小写
lower_case_table_names = 1
open_files_limit = 30000
table_open_cache = 2048
#TIMESTAMP如果没有显示声明NOT NULL，是允许NULL值的，可以直接设置改列为NULL，而没有默认填充行为。
#TIMESTAMP不会默认分配DEFAULT CURRENT_TIMESTAMP 和 ON UPDATE CURRENT_TIMESTAMP属性
explicit_defaults_for_timestamp=true
#开启定时任务
event_scheduler=1
# MySQL 服务所允许的同时会话数的上限
max_connections = 3000
# 每个客户端连接最大的错误允许数量如果达到了此限制
# 这个客户端将会被MySQL服务阻止直到执行了”FLUSH HOSTS” 或者服务重启
# 非法的密码以及其他在链接时的错误会增加此值
# 查看 “Aborted_connects” 状态来获取全局计数器
max_connect_errors = 100000
# 服务所能处理的请求包的最大大小以及服务所能处理的最大的请求大小(当与大的BLOB字段一起工作时相当必要)
# 每个连接独立的大小.大小动态增加
max_allowed_packet = 32M
# 在一个事务中binlog为了记录SQL状态所持有的cache大小
# 如果你经常使用大的多声明的事务你可以增加此值来获取更大的性能
# 所有从事务来的状态都将被缓冲在binlog缓冲中然后在提交后一次性写入到binlog中
# 如果事务比此值大 会使用磁盘上的临时文件来替代
# 此缓冲在每个连接的事务第一次更新状态时被创建
binlog_cache_size = 4M
# 独立的内存表所允许的最大容量
# 此选项为了防止意外创建一个超大的内存表导致永尽所有的内存资源
max_heap_table_size = 256M
# 排序缓冲被用来处理类似ORDER BY以及GROUP BY队列所引起的排序
# 如果排序后的数据无法放入排序缓冲
# 一个用来替代的基于磁盘的合并分类会被使用
# 查看 “Sort_merge_passes” 状态变量
# 在排序发生时由每个线程分配
sort_buffer_size = 32M
# 此缓冲被使用来优化全联合(full JOINs 不带索引的联合)
# 类似的联合在极大多数情况下有非常糟糕的性能表现
# 但是将此值设大能够减轻性能影响
# 通过 “Select_full_join” 状态变量查看全联合的数量
# 当全联合发生时在每个线程中分配
join_buffer_size = 32M
# 我们在cache中保留多少线程用于重用
# 当一个客户端断开连接后如果cache中的线程还少于thread_cache_size
# 则客户端线程被放入cache中
# 这可以在你需要大量新连接的时候极大的减少线程创建的开销
# (一般来说如果你有好的线程模型的话这不会有明显的性能提升)
thread_cache_size = 8
# 内部(内存中)临时表的最大大小
# 如果一个表增长到比此值更大将会自动转换为基于磁盘的表
# 此限制是针对单个表的而不是总和
tmp_table_size = 256M
# 记录慢速查询. 慢速查询是指消耗了比 “long_query_time” 定义的更多时间的查询
# 如果 log_long_format 被打开那些没有使用索引的查询也会被记录
# 如果你经常增加新查询到已有的系统内的话. 一般来说这是一个好主意
slow-query-log = 1
# 所有的使用了比这个时间(以秒为单位)更多的查询会被认为是慢速查询
# 不要在这里使用”1″ 否则会导致所有的查询甚至非常快的查询页被记录下来(由于MySQL 目前时间的精确度只能达到秒的级别)
long_query_time = 5
slow-query-log-file= /opt/mysqldata/dbslowlog/db-slow.log
# 此目录被MySQL用来保存临时文件.例如
# 它被用来处理基于磁盘的大型排序和内部排序一样
# 以及简单的临时表
# 如果你不创建非常大的临时文件将其放置到 swapfs/tmpfs 文件系统上也许比较好
# 另一种选择是你也可以将其放置在独立的磁盘上
# 你可以使用”;”来放置多个路径
# 他们会按照roud-robin方法被轮询使用
tmpdir = /tmp
############################# INNODB 服务端 #############################
# InnoDB使用一个缓冲池来保存索引和原始数据 不像 MyISAM
# 这里你设置越大你在存取表里面数据时所需要的磁盘I/O越少
# 在一个独立使用的数据库服务器上你可以设置这个变量到服务器物理内存大小的80%
# 不要设置过大否则由于物理内存的竞争可能导致操作系统的换页颠簸
# 注意在32位系统上你每个进程可能被限制在 2-3.5G 用户层面内存限制
# 所以不要设置的太高
innodb_buffer_pool_size = 20G
#千万不要用默认的10M，否则在有高并发事务时，会受到不小的影响
innodb_data_file_path = ibdata1:10M:autoextend
# 在InnoDb核心内的允许线程数量
# 最优值依赖于应用程序硬件以及操作系统的调度方式
# 过高的值可能导致线程的互斥颠簸
innodb_thread_concurrency = 8
# 如果设置为1 InnoDB会在每次提交后刷新(fsync)事务日志到磁盘上
# 这提供了完整的ACID行为
# 如果你愿意对事务安全折衷 并且你正在运行一个小的食物 你可以设置此值到0或者2来减少由事务日志引起的磁盘I/O
# 0代表日志只大约每秒写入日志文件并且日志文件刷新到磁盘
# 1代表比较安全，但性能降低
# 2代表日志写入日志文件在每次提交后但是日志文件只有大约每秒才会刷新到磁盘上
innodb_flush_log_at_trx_commit = 2
# 用来缓冲日志数据的缓冲区的大小
# 当此值快满时 InnoDB将必须刷新数据到磁盘上
# 由于基本上每秒都会刷新一次所以没有必要将此值设置的太大(甚至对于长事务而言)
innodb_log_buffer_size = 16M
# 在日志组中每个日志文件的大小
# 你应该设置日志文件总合大小到你缓冲池大小的25%~100%
# 来避免在日志文件覆写上不必要的缓冲池刷新行为
# 不论如何 请注意一个大的日志文件大小会增加恢复进程所需要的时间
innodb_log_file_size = 512M
# 在日志组中的文件总数
# 通常来说2~3是比较好的
innodb_log_files_in_group = 3
# InnoDB的日志文件所在位置. 默认是MySQL的datadir
# 你可以将其指定到一个独立的硬盘上或者一个RAID1卷上来提高其性能
#innodb_log_group_home_dir = /opt/mysql/data
innodb_log_group_home_dir = /opt/mysqldata/log
# 在InnoDB缓冲池中最大允许的脏页面的比例
# 如果达到限额 InnoDB会开始刷新他们防止他们妨碍到干净数据页面
# 这是一个软限制不被保证绝对执行
innodb_max_dirty_pages_pct = 90
# InnoDB用来刷新日志的方法
# 表空间总是使用双重写入刷新方法 Unix可以设置：fsync() or O_SYNC/O_DSYNC
# 默认值是 “fdatasync” 另一个是 “O_DSYNC” Linux可以选择：O_DIRECT
innodb_flush_method=O_DIRECT
# 在被回滚前一个InnoDB的事务应该等待一个锁被批准多久
# InnoDB在其拥有的锁表中自动检测事务死锁并且回滚事务
# 如果你使用 LOCK TABLES 指令 或者在同样事务中使用除了InnoDB以外的其他事务安全的存储引擎
# 那么一个死锁可能发生而InnoDB无法注意到
# 这种情况下这个timeout值对于解决这种问题就非常有帮助
innodb_lock_wait_timeout = 120
############################ mysqld_safe 配置 ############################
[mysqld_safe]
# 增加每个进程的可打开文件数量
# 警告: 确认你已经将全系统限制设定的足够高
# 打开大量表需要将此值设大
open-files-limit =30000
